Q1. 큐 자료구조의 특징을 간단히 설명하라
큐는 선입선출의 원리를 따르는 선형자료구조이다.

큐를 이루는 요소로는 다음이 있다.
1. front    : 큐의 앞을 나타내는 index
2. rear     : 큐의 뒤를 나타내는 index
3. enQueue  : 큐에 값을 넣는 함수
4. deQueue  : 큐에서 값을 빼는 함수
5. isEmpty  : 큐에 값이 없는지 확인하는 함수
6. isFull   : 큐에 값이 가득 찼는지 확인하는 함수

큐의 구현은 다음과 같다.
```Queue
arr = [1, 2, 3, 4, 5]
n = len(arr)

Queue = [0]*n   # 적절한 크기의 Queue를 미리 만들어야 한다.
front = -1
rear = -1

def enQueue(Queue, Value):
    rear += 1
    Queue[rear] = Value


def deQueue(Queue):
    front += 1
    return Queue[front]


def isEmpty(Queue):
    return front == rear


def isFull(Queue):
    return rear == (n - 1)
```

큐의 특성을 응용하면 원형 큐, 우선순위 큐 등을 만들 수 있다.
원형 큐의 경우, index 가 큐의 범위를 넘게 되면 다시 0부터 세는 방식을 이용한다.
우선순위 큐의 경우, 먼저 들어온 값과 비교를 통해 재배열을 하는 방법을 사용한다.

Q2. BFS 에 대해 설명하라.
자료 탐색시, 시작 지점에서 가까운 순서대로 탐색을 하는 방식을 말한다.

BFS 는 큐와 방문기록를 통해 구현할 수 있다.
```BFS
graph = {1: [2, 3], 2: [1, 4, 5], 3: [1, 7],
         4: [2, 6], 5: [2, 6], 6: [4, 5, 7], 7: [3, 6]}


def BFS(graph, start, end):
    Queue = [0]*N       # 적절한 크기의 큐 생성
    front = -1
    rear = -1
    visited = [0]*M     # 적절한 크기의 방문기록 생성

    rear += 1
    Queue[rear] = start
    visited[start] = 1
    while front != rear:
        front += 1
        now = Queue[front]
        if now == end:
            return True         # 원하는 값을 찾으면 True 반환
        for i in graph[now]:
            if not visited[i]:
                rear += 1
                Queue[rear] = i
                visited[i] = 1
    else:
        return False    # 원하는 값을 찾지 못하면 False 반환
```

Q3. 예시에서 BFS 방문 순서 찾기.
4 2 6 1 5 7 3

1. 4번에서 시작 (4)
2. 4번에서 가장 가까운 숫자인 2, 6 중 빠른 번호순으로 출력 (4 2 6)
3. 다음으로, 2번에서 시작하여 2번에서 1, 5 중 빠른 번호순으로 출력 (4 2 6 1 5)
4. 다음은 시작점에서 가까운 6번에서 탐색한 5를 제외하고 7을 출력 (4 2 6 1 5 7)
5. 마지막으로 1번에서 가까운 3을 출력 (4 2 6 1 5 7 3)
6. 5, 7, 3은 인접한 노드 중 방문하지 않은 곳이 없으므로 생략

(구현 코드는 Q2를 참조)
